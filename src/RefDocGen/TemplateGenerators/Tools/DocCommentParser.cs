using RefDocGen.CodeElements.Abstract;
using RefDocGen.CodeElements.Abstract.Types;
using RefDocGen.CodeElements.Concrete;
using RefDocGen.CodeElements.Concrete.Types;
using RefDocGen.CodeElements.Concrete.Types.Delegate;
using RefDocGen.CodeElements.Concrete.Types.Enum;
using RefDocGen.DocExtraction.Tools;
using RefDocGen.TemplateGenerators.Tools.TypeName;
using RefDocGen.Tools.Xml;
using System.Xml.Linq;

namespace RefDocGen.TemplateGenerators.Tools;

internal interface IDocCommentParser
{
    string ToHtmlString(XElement docComment);
}

internal abstract class DefaultDocCommentParser : IDocCommentParser
{

    /// <summary>
    /// Marks the <paramref name="element"/> and all of its child elements as generated by the app.
    /// </summary>
    /// <param name="element"></param>
    /// <returns></returns>
    private XElement MarkAsGenerated(XElement element)
    {
        var attribute = new XAttribute("refdocgen-generated", true);

        element.Add(attribute);

        foreach (var e in element.Elements())
        {
            _ = MarkAsGenerated(e);
        }

        return new XElement(element);
    }

    private void Transform(XElement before, XElement template)
    {
        var newElement = MarkAsGenerated(template);

        var deepestChild = newElement.GetEmptyDescendantOrSelf();
        deepestChild.Add(before.Nodes());

        CustomReplace(before, newElement);
    }

    private void Transform(XElement before, XElement template, string attribute)
    {
        var newElement = MarkAsGenerated(template);

        var deepestChild = newElement.GetEmptyDescendantOrSelf();
        deepestChild.Add(before.Nodes());

        if (before.Attribute(attribute) is XAttribute attr && !before.Nodes().Any())
        {
            deepestChild.Add(attr.Value);
        }

        CustomReplace(before, newElement);
    }

    private void CustomReplace(XElement node1, XElement node2)
    {
        if (node1 == node2)
        {
            return;
        }

        node1.Name = node2.Name;
        node1.ReplaceAttributes(node2.Attributes());
        node1.ReplaceNodes(node2.Nodes());
    }

    protected readonly ITypeRegistry typeRegistry;

    protected virtual XElement ParagraphElement => new("div");

    protected virtual XElement BulletListElement => new("ul");

    protected virtual XElement NumberListElement => new("ol");

    protected virtual XElement ListItemElement => new("li");

    protected virtual XElement InlineCodeElement => new("code");

    protected virtual XElement CodeBlockElement => new("pre",
                                                        new XElement("code")
                                                    );

    protected virtual XElement ExampleElement => new("div");

    protected virtual XElement ParamRefElement => new("xxx");

    protected virtual XElement TypeParamRefElement => new("code");

    protected virtual XElement SeeCrefElement => new("a");

    protected virtual XElement SeeHrefElement => new("a");

    protected virtual XElement SeeLangwordElement => new("code");

    protected virtual XElement SeeCrefNotFoundElement => new("code");

    protected virtual XElement SeeAlsoCrefElement => new("a");

    protected virtual XElement SeeAlsoHrefElement => new("a");

    protected virtual XElement SeeAlsoNotFoundElement => new("code");

    private readonly string[] toRemove = ["summary", "remarks", "returns", "exception", "value"];

    protected DefaultDocCommentParser(ITypeRegistry typeRegistry)
    {
        this.typeRegistry = typeRegistry;
    }

    protected DefaultDocCommentParser() // TODO: code smell
    {
        typeRegistry = new TypeRegistry(
                new Dictionary<string, ObjectTypeData>(),
                new Dictionary<string, EnumTypeData>(),
                new Dictionary<string, DelegateTypeData>()
            );
    }

    public string ToHtmlString(XElement docComment)
    {
        var docCommentCopy = new XElement(docComment);
        TransformToHtml(docCommentCopy);

        return docCommentCopy.ToString();
    }

    private void TransformToHtml(XElement element)
    {
        if (element.Attribute("refdocgen-generated") is null)
        {
            if (element.Name == "para")
            {
                TransformParagraphElement(element);
            }
            else if (element.Name == "list")
            {
                TransformListElement(element);
            }
            else if (element.Name == "item")
            {
                TransformListItemElement(element);
            }
            else if (element.Name == "c")
            {
                TransformInlineCodeElement(element);
            }
            else if (element.Name == "code")
            {
                TransformCodeBlockElement(element);
            }
            else if (element.Name == "example")
            {
                TransformExampleElement(element);
            }
            else if (element.Name == "see")
            {
                TransformSeeElement(element);
            }
            else if (element.Name == "seealso")
            {
                TransformSeeElement(element); // TODO: add
            }
            else if (element.Name == "paramref")
            {
                TransformParamRefElement(element);
            }
            else if (element.Name == "typeparamref")
            {
                TransformTypeParamRefElement(element);
            }
            else if (toRemove.Contains(element.Name.LocalName))
            {
                element.Name = "div";
            }
        }

        foreach (var child in element.Elements())
        {
            TransformToHtml(child);
        }
    }

    protected virtual void TransformListElement(XElement element)
    {
        string listType = element.Attribute("type")?.Value ?? "bullet";

        var types = new Dictionary<string, XElement>()
        {
            ["bullet"] = BulletListElement,
            ["number"] = NumberListElement,
            ["table"] = BulletListElement, // TODO: add 
        };

        if (types.TryGetValue(listType, out var newElement))
        {
            Transform(element, newElement);
        }
    }

    protected virtual void TransformListItemElement(XElement element)
    {
        Transform(element, ListItemElement);
    }

    protected virtual void TransformParagraphElement(XElement element)
    {
        Transform(element, ParagraphElement);
    }

    protected virtual void TransformInlineCodeElement(XElement element)
    {
        Transform(element, InlineCodeElement);
    }

    protected virtual void TransformCodeBlockElement(XElement element)
    {
        Transform(element, CodeBlockElement);
    }

    protected virtual void TransformExampleElement(XElement element)
    {
        Transform(element, ExampleElement);
    }

    protected virtual void TransformSeeElement(XElement element)
    {
        if (element.Attribute(XmlDocIdentifiers.Href) is XAttribute hrefAttr)
        {
            TransformAnySeeHrefElement(element, hrefAttr.Value);
        }
        else if (element.Attribute(XmlDocIdentifiers.Cref) is XAttribute crefAttr)
        {
            TransformAnySeeCrefElement(element, crefAttr.Value);
        }
        else if (element.Attribute(XmlDocIdentifiers.Langword) is XAttribute langwordAttr)
        {
            TransformAnySeeLangwordElement(element, langwordAttr.Value);
        }
    }

    protected virtual void TransformAnySeeHrefElement(XElement element, string hrefValue)
    {
        var newElement = MarkAsGenerated(SeeHrefElement);
        var deepestChild = newElement.GetEmptyDescendantOrSelf();

        if (element.Nodes().Any())
        {
            deepestChild.Add(element.Nodes());
        }
        else
        {
            deepestChild.Add(hrefValue);
        }

        deepestChild.Add(
            new XAttribute(XmlDocIdentifiers.Href, hrefValue)
            );

        CustomReplace(element, newElement);
    }

    protected virtual void TransformAnySeeLangwordElement(XElement element, string langword)
    {
        Transform(element, SeeLangwordElement, XmlDocIdentifiers.Langword);
    }

    protected virtual void TransformAnySeeCrefElement(XElement element, string crefValue)
    {
        string[] splitMemberName = crefValue.Split(':');
        (string objectIdentifier, string fullObjectName) = (splitMemberName[0], splitMemberName[1]);

        string typeId;
        string? memberId = null;

        if (objectIdentifier == MemberTypeId.Type) // type
        {
            typeId = fullObjectName;
        }
        else if (objectIdentifier == "!") // reference not found
        {
            TransformNotFoundCrefElement(element, fullObjectName);
            return;
        }
        else // member
        {
            (typeId, string memberName, string paramsString) = MemberSignatureParser.Parse(fullObjectName);
            memberId = memberName + paramsString;
        }

        // type found
        if (typeRegistry.GetDeclaredType(typeId) is ITypeDeclaration type)
        {
            var newElement = MarkAsGenerated(SeeCrefElement);
            var deepestChild = newElement.GetEmptyDescendantOrSelf();

            string target = typeId + ".html";
            string targetName = CSharpTypeName.Of(type);

            // TODO: check if member is found

            if (memberId is not null)
            {
                target += $"#{memberId}";
                targetName += $".{memberId}";
            }

            deepestChild.Add(
                new XAttribute(XmlDocIdentifiers.Href, target)
            );

            // no child nodes -> add cref 
            if (!element.Nodes().Any())
            {
                deepestChild.Add(targetName);
            }
            else
            {
                deepestChild.Add(element.Nodes());
            }

            CustomReplace(element, newElement);
        }
        else // type not found
        {
            var newElement = MarkAsGenerated(SeeAlsoNotFoundElement);
            var deepestChild = newElement.GetEmptyDescendantOrSelf();

            deepestChild.Add();

            if (!element.Nodes().Any())
            {
                deepestChild.Add(new XText(fullObjectName));
            }
            else
            {
                deepestChild.Add(element.Nodes());
            }

            CustomReplace(element, newElement);
        }
    }

    protected virtual void TransformNotFoundCrefElement(XElement element, string crefValue)
    {
        Transform(element, SeeCrefNotFoundElement, XmlDocIdentifiers.Cref);
    }

    protected virtual void TransformParamRefElement(XElement element)
    {
        TransformAnyParamRefElement(element, ParamRefElement);
    }

    protected virtual void TransformTypeParamRefElement(XElement element)
    {
        TransformAnyParamRefElement(element, TypeParamRefElement);
    }

    protected virtual void TransformAnyParamRefElement(XElement element, XElement htmlElement)
    {
        Transform(element, htmlElement, XmlDocIdentifiers.Name);
    }
}

internal class CustomDocCommentParser : DefaultDocCommentParser
{
    public CustomDocCommentParser()
    {
    }

    public CustomDocCommentParser(ITypeRegistry typeRegistry) : base(typeRegistry)
    {
    }

    protected override XElement ParamRefElement =>
        new(
            "code",
            new XAttribute("class", "text-warning bg-success")); // TODO: just for demo, remove afterwards
}
