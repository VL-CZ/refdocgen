using RefDocGen.CodeElements.Abstract;
using RefDocGen.CodeElements.Abstract.Types;
using RefDocGen.CodeElements.Concrete;
using RefDocGen.CodeElements.Concrete.Types;
using RefDocGen.CodeElements.Concrete.Types.Delegate;
using RefDocGen.CodeElements.Concrete.Types.Enum;
using RefDocGen.DocExtraction.Tools;
using RefDocGen.TemplateGenerators.Tools.TypeName;
using RefDocGen.Tools.Xml;
using System.Xml.Linq;

namespace RefDocGen.TemplateGenerators.Tools;

/// <summary>
/// Defines the configuration for transforming XML documentation elements to HTML representations.
/// </summary>
internal interface IConfiguration
{
    /// <summary>
    /// The HTML representation of the <c>&lt;para&gt;</c> element.
    /// </summary>
    XElement ParagraphElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;list type="bullet"&gt;</c> element.
    /// </summary>
    XElement BulletListElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;list type="number"&gt;</c> element.
    /// </summary>
    XElement NumberListElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;item&gt;</c> element.
    /// </summary>
    XElement ListItemElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;c&gt;</c> element.
    /// </summary>
    XElement InlineCodeElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;code&gt;</c> element.
    /// </summary>
    XElement CodeBlockElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;example&gt;</c> element.
    /// </summary>
    XElement ExampleElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;paramref&gt;</c> element.
    /// </summary>
    XElement ParamRefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;typeparamref&gt;</c> element.
    /// </summary>
    XElement TypeParamRefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;see cref="..."&gt;</c> element.
    /// </summary>
    XElement SeeCrefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;see href="..."&gt;</c> element.
    /// </summary>
    XElement SeeHrefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;see langword="..."&gt;</c> element.
    /// </summary>
    XElement SeeLangwordElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;see cref="..."&gt;</c> element, whose reference isn't found.
    /// </summary>
    XElement SeeCrefNotFoundElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;seealso cref="..."&gt;</c> element.
    /// </summary>
    XElement SeeAlsoCrefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;seealso href="..."&gt;</c> element.
    /// </summary>
    XElement SeeAlsoHrefElement { get; }

    /// <summary>
    /// The HTML representation of the <c>&lt;seealso cref="..."&gt;</c> element, whose reference isn't found.
    /// </summary>
    XElement SeeAlsoCrefNotFoundElement { get; }
}

/// <inheritdoc />
internal class DefaultConfiguration : IConfiguration
{
    /// <inheritdoc />
    public virtual XElement ParagraphElement => new("div");

    /// <inheritdoc />
    public virtual XElement BulletListElement => new("ul");

    /// <inheritdoc />
    public virtual XElement NumberListElement => new("ol");

    /// <inheritdoc />
    public virtual XElement ListItemElement => new("li");

    /// <inheritdoc />
    public virtual XElement InlineCodeElement => new("code");

    /// <inheritdoc />
    public virtual XElement CodeBlockElement => new("pre",
        new XElement("code"));

    /// <inheritdoc />
    public virtual XElement ExampleElement => new("div");

    /// <inheritdoc />
    public virtual XElement ParamRefElement => new("xxx");

    /// <inheritdoc />
    public virtual XElement TypeParamRefElement => new("code");

    /// <inheritdoc />
    public virtual XElement SeeCrefElement => new("a");

    /// <inheritdoc />
    public virtual XElement SeeHrefElement => new("a");

    /// <inheritdoc />
    public virtual XElement SeeLangwordElement => new("code");

    /// <inheritdoc />
    public virtual XElement SeeCrefNotFoundElement => new("code");

    /// <inheritdoc />
    public virtual XElement SeeAlsoCrefElement => new("a");

    /// <inheritdoc />
    public virtual XElement SeeAlsoHrefElement => new("a");

    /// <inheritdoc />
    public virtual XElement SeeAlsoCrefNotFoundElement => new("code");
}

internal interface IDocCommentParser
{
    string ToHtmlString(XElement docComment);
}

internal class DefaultDocCommentParser : IDocCommentParser
{
    /// <summary>
    /// Marks the <paramref name="element"/> and all of its child elements as generated by the app.
    /// </summary>
    /// <param name="element"></param>
    /// <returns></returns>
    private XElement MarkAsGenerated(XElement element)
    {
        var attribute = new XAttribute("refdocgen-generated", true);

        element.Add(attribute);

        foreach (var e in element.Elements())
        {
            _ = MarkAsGenerated(e);
        }

        return new XElement(element);
    }

    private XElement Transform(XElement before, XElement template)
    {
        var newElement = MarkAsGenerated(template);

        var deepestChild = newElement.GetEmptyDescendantOrSelf();
        deepestChild.Add(before.Nodes());

        return newElement;
    }

    private XElement Transform(XElement before, XElement template, string attributeName, bool addAttribute = false)
    {
        var newElement = MarkAsGenerated(template);

        var deepestChild = newElement.GetEmptyDescendantOrSelf();
        deepestChild.Add(before.Nodes());

        if (before.Attribute(attributeName) is XAttribute attr)
        {
            if (!before.Nodes().Any())
            {
                deepestChild.Add(attr.Value);
            }
            if (addAttribute)
            {
                deepestChild.SetAttributeValue(attributeName, attr.Value);
            }
        }

        return newElement;
    }

    private void CustomReplace(XElement node1, XElement node2)
    {
        if (node1 == node2)
        {
            return;
        }

        node1.Name = node2.Name;
        node1.ReplaceAttributes(node2.Attributes());
        node1.ReplaceNodes(node2.Nodes());
    }

    protected readonly ITypeRegistry typeRegistry;

    private readonly IConfiguration configuration;

    private readonly string[] toRemove = ["summary", "remarks", "returns", "exception", "value"];

    internal DefaultDocCommentParser(ITypeRegistry typeRegistry, IConfiguration configuration)
    {
        this.typeRegistry = typeRegistry;
        this.configuration = configuration;
    }

    internal DefaultDocCommentParser(IConfiguration? configuration = null) // TODO: code smell
    {
        typeRegistry = new TypeRegistry(
                new Dictionary<string, ObjectTypeData>(),
                new Dictionary<string, EnumTypeData>(),
                new Dictionary<string, DelegateTypeData>()
            );

        this.configuration = configuration ?? new DefaultConfiguration();
    }

    public string ToHtmlString(XElement docComment)
    {
        var docCommentCopy = new XElement(docComment);
        TransformToHtml(docCommentCopy);

        return docCommentCopy.ToString();
    }

    private void TransformToHtml(XElement element)
    {
        var transformedElement = element;

        if (element.Attribute("refdocgen-generated") is null)
        {
            if (element.Name == "para")
            {
                transformedElement = TransformParagraphElement(element);
            }
            else if (element.Name == "list")
            {
                transformedElement = TransformListElement(element);
            }
            else if (element.Name == "item")
            {
                transformedElement = TransformListItemElement(element);
            }
            else if (element.Name == "c")
            {
                transformedElement = TransformInlineCodeElement(element);
            }
            else if (element.Name == "code")
            {
                transformedElement = TransformCodeBlockElement(element);
            }
            else if (element.Name == "example")
            {
                transformedElement = TransformExampleElement(element);
            }
            else if (element.Name == "see")
            {
                transformedElement = TransformSeeElement(element);
            }
            else if (element.Name == "seealso")
            {
                transformedElement = TransformSeeElement(element); // TODO: add
            }
            else if (element.Name == "paramref")
            {
                transformedElement = TransformParamRefElement(element);
            }
            else if (element.Name == "typeparamref")
            {
                transformedElement = TransformTypeParamRefElement(element);
            }
            else if (toRemove.Contains(element.Name.LocalName))
            {
                element.Name = "div";
                transformedElement = element;
            }
        }

        CustomReplace(element, transformedElement);

        foreach (var child in element.Elements())
        {
            TransformToHtml(child);
        }
    }

    /// <summary>
    /// Transforms the <c>&lt;list&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;list&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;list&gt;</c> element.</returns>
    protected virtual XElement TransformListElement(XElement element)
    {
        string listType = element.Attribute("type")?.Value ?? "bullet";

        var types = new Dictionary<string, XElement>()
        {
            ["bullet"] = configuration.BulletListElement,
            ["number"] = configuration.NumberListElement,
            ["table"] = configuration.BulletListElement, // TODO: add 
        };

        return types.TryGetValue(listType, out var newElement)
            ? Transform(element, newElement)
            : element;
    }

    /// <summary>
    /// Transforms the <c>&lt;item&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;item&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;item&gt;</c> element.</returns>
    protected virtual XElement TransformListItemElement(XElement element)
    {
        return Transform(element, configuration.ListItemElement);
    }

    /// <summary>
    /// Transforms the <c>&lt;para&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;para&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;para&gt;</c> element.</returns>
    protected virtual XElement TransformParagraphElement(XElement element)
    {
        return Transform(element, configuration.ParagraphElement);
    }

    /// <summary>
    /// Transforms the <c>&lt;c&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;c&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;c&gt;</c> element.</returns>
    protected virtual XElement TransformInlineCodeElement(XElement element)
    {
        return Transform(element, configuration.InlineCodeElement);
    }

    /// <summary>
    /// Transforms the <c>&lt;code&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;code&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;code&gt;</c> element.</returns>
    protected virtual XElement TransformCodeBlockElement(XElement element)
    {
        return Transform(element, configuration.CodeBlockElement);
    }

    /// <summary>
    /// Transforms the <c>&lt;example&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;example&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;example&gt;</c> element.</returns>
    protected virtual XElement TransformExampleElement(XElement element)
    {
        return Transform(element, configuration.ExampleElement);
    }

    /// <summary>
    /// Transforms any <c>&lt;see&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;see&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;see&gt;</c> element.</returns>
    protected virtual XElement TransformSeeElement(XElement element)
    {
        if (element.Attribute(XmlDocIdentifiers.Href) is XAttribute hrefAttr)
        {
            return TransformSeeHrefElement(element, hrefAttr.Value);
        }
        else if (element.Attribute(XmlDocIdentifiers.Cref) is XAttribute crefAttr)
        {
            return TransformSeeCrefElement(element, crefAttr.Value);
        }
        else if (element.Attribute(XmlDocIdentifiers.Langword) is not null)
        {
            return TransformSeeLangwordElement(element);
        }
        else
        {
            return element;
        }
    }

    /// <summary>
    /// Transforms the <c>&lt;see cref="..."&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;see&gt;</c> element to transform.</param>
    /// <param name="crefValue">Value of the <c>cref</c> attribute.</param>
    /// <returns>The HTML representation of the <c>&lt;see cref="..."&gt;</c> element.
    /// <para>
    /// If the referenced object is not found, the HTML representation of the not found <c>cref</c> element is returned.
    /// </para>
    /// </returns>
    protected virtual XElement TransformSeeCrefElement(XElement element, string crefValue)
    {
        return TransformAnyCrefElement(element, configuration.SeeCrefElement, configuration.SeeCrefNotFoundElement, crefValue);
    }

    /// <summary>
    /// Transforms the <c>&lt;see href="..."&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;see&gt;</c> element to transform.</param>
    /// <param name="hrefValue">Value of the <c>href</c> attribute.</param>
    /// <returns>The HTML representation of the <c>&lt;see href="..."&gt;</c> element.</returns>
    protected virtual XElement TransformSeeHrefElement(XElement element, string hrefValue)
    {
        return Transform(element, configuration.SeeHrefElement, XmlDocIdentifiers.Href, true);
    }

    /// <summary>
    /// Transforms the <c>&lt;see langword="..."&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;see&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;see langword="..."&gt;</c> element.</returns>
    protected virtual XElement TransformSeeLangwordElement(XElement element)
    {
        return Transform(element, configuration.SeeLangwordElement, XmlDocIdentifiers.Langword);
    }

    /// <summary>
    /// Transforms any <c>&lt;seealso&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;seealso&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;seealso&gt;</c> element.</returns>
    protected virtual XElement TransformSeeAlsoElement(XElement element)
    {
        if (element.Attribute(XmlDocIdentifiers.Href) is XAttribute hrefAttr)
        {
            return TransformSeeHrefElement(element, hrefAttr.Value);
        }
        else if (element.Attribute(XmlDocIdentifiers.Cref) is XAttribute crefAttr)
        {
            return TransformSeeCrefElement(element, crefAttr.Value);
        }
        else
        {
            return element;
        }
    }

    /// <summary>
    /// Transforms the <c>&lt;seealso href="..."&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;seealso&gt;</c> element to transform.</param>
    /// <param name="hrefValue">Value of the <c>href</c> attribute.</param>
    /// <returns>The HTML representation of the <c>&lt;seealso href="..."&gt;</c> element.</returns>
    protected virtual XElement TransformSeeAlsoHrefElement(XElement element, string hrefValue)
    {
        return Transform(element, configuration.SeeAlsoHrefElement, XmlDocIdentifiers.Href, true);
    }

    /// <summary>
    /// Transforms the <c>&lt;seealso cref="..."&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;seealso&gt;</c> element to transform.</param>
    /// <param name="crefValue">Value of the <c>cref</c> attribute.</param>
    /// <returns>
    /// The HTML representation of the <c>&lt;seealso cref="..."&gt;</c> element.
    /// <para>
    /// If the referenced object is not found, the HTML representation of the not found <c>cref</c> element is returned.
    /// </para>
    /// </returns>
    protected virtual XElement TransformSeeAlsoCrefElement(XElement element, string crefValue)
    {
        return TransformAnyCrefElement(element, configuration.SeeAlsoCrefElement, configuration.SeeAlsoCrefNotFoundElement, crefValue);
    }

    /// <summary>
    /// Transforms the <c>&lt;paramref&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;paramref&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;paramref&gt;</c> element.</returns>
    protected virtual XElement TransformParamRefElement(XElement element)
    {
        return Transform(element, configuration.ParamRefElement, XmlDocIdentifiers.Name);
    }

    /// <summary>
    /// Transforms the <c>&lt;paramref&gt;</c> element to its HTML representation.
    /// </summary>
    /// <param name="element">The <c>&lt;paramref&gt;</c> element to transform.</param>
    /// <returns>The HTML representation of the <c>&lt;paramref&gt;</c> element.</returns>
    protected virtual XElement TransformTypeParamRefElement(XElement element)
    {
        return Transform(element, configuration.TypeParamRefElement, XmlDocIdentifiers.Name);
    }

    private XElement TransformAnyCrefElement(XElement element, XElement foundHtmltemplate, XElement notFoundHtmlTemplate, string crefValue)
    {
        string[] splitMemberName = crefValue.Split(':');
        (string objectIdentifier, string fullObjectName) = (splitMemberName[0], splitMemberName[1]);

        string typeId;
        string? memberId = null;

        if (objectIdentifier == CodeElementId.Type) // type
        {
            typeId = fullObjectName;
        }
        else if (CodeElementId.IsMember(objectIdentifier)) // member
        {
            (typeId, string memberName, string paramsString) = MemberSignatureParser.Parse(fullObjectName);
            memberId = memberName + paramsString;
        }
        else // reference not found
        {
            return Transform(element, notFoundHtmlTemplate, XmlDocIdentifiers.Cref);
        }

        // type found
        if (typeRegistry.GetDeclaredType(typeId) is ITypeDeclaration type)
        {
            var newElement = MarkAsGenerated(foundHtmltemplate);
            var deepestChild = newElement.GetEmptyDescendantOrSelf();

            string target = typeId + ".html";
            string targetName = CSharpTypeName.Of(type);

            // TODO: check if member is found

            if (memberId is not null)
            {
                target += $"#{memberId}";
                targetName += $".{memberId}";
            }

            deepestChild.Add(
                new XAttribute(XmlDocIdentifiers.Href, target)
            );

            // no child nodes -> add cref 
            if (!element.Nodes().Any())
            {
                deepestChild.Add(targetName);
            }
            else
            {
                deepestChild.Add(element.Nodes());
            }

            return newElement;
        }
        else // type not found
        {
            var newElement = MarkAsGenerated(notFoundHtmlTemplate);
            var deepestChild = newElement.GetEmptyDescendantOrSelf();

            deepestChild.Add();

            if (!element.Nodes().Any())
            {
                deepestChild.Add(new XText(fullObjectName));
            }
            else
            {
                deepestChild.Add(element.Nodes());
            }

            return newElement;
        }
    }
}

internal class CustomConfiguration : DefaultConfiguration
{
    public override XElement ParamRefElement =>
        new(
            "code",
            new XAttribute("class", "text-warning bg-success")); // TODO: just for demo, remove afterwards
}
